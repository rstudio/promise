---
title: "Advanced `future` and `promises` usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{5. Advanced future and promises usage}
  %\VignetteEncoding{UTF-8}
---

This article discusses the benefits of using `promises::future_promise()` over a combination of `future::future()` + `promises::promise()` to better take advantage of computing resources available to your main R session. To demonstrate these benefits, we'll walk-through a use-case with the `plumber` package. ([See here](https://www.rplumber.io/) to learn more about `plumber` and [this article](futures.html) to learn more about `future`.)

In an ideal situation, the number of available `future` (>= 1.21.0) workers (`future::nbrOfFreeWorkers()`) is always **more than** the number of `future::future()` jobs. However, if a `future` job is attempted when the number of free workers is `0`, then `future` will block the current R session until one becomes available. For a concrete example of where this can become an issue, let's imagine a scenario with seven `plumber` requests being received at the same time with only two `future` workers.

The figure below displays the time required to process those seven requests. The trailing number at the end of each request is the request's arrival order.  The first six requests use `future::future()` and will take ~10s to compute. The final request will not be using any form of `future` or `promises`.

Using two `future` workers, the execution timeline would look like:

![Early workers take more time than expected. Main R session is blocked](./future_promise/future.png){width=75%}


While the overall time is faster than if the requests were serially executed, the turn around time for earlier routes (e.g. `/slow/1`) will be longer than expected. This is because the main R session is blocked waiting for a `future` worker to become available.  Blocking the main R session prevents any pending `promises` objects (or `later` callbacks) from being executed, such as responding to a `plumber` route executed by `future`.

![future does not respond to anything until the main R session is _free_](./future_promise/blocked_future.png){width=75%}

The video below animates how the main R process has to wait for `future` workers to become available before being able to process the next incoming `plumber` request:

```{r, echo = FALSE}
library(vembedr)
embed_vimeo("505287449") %>%
  use_align("center")
```


## `future_promise()`

`future_promise()` creates a _promise_ that will resolve to the final value of `future::future()` execution.

The advantage of `future_promise()` is that it will not attempt `future` work unless a `future` worker is available. If no workers are available (due to other `future::future()` calls), `future_promise()` will continue to periodically check for a worker to become available. This keeps the main R session available even if there are more `future_promise()` objects submitted than there are `future` workers.

Continuing with the example above, we can swap out the calls to `future::future()` with `future_promise()`.  In the timeline plot below, the `/fast/7` route will not have to wait on any `future` work to finish processing.  While waiting for the `future` jobs to complete, the main R session is not blocked.

Using two `future` workers and `future_promise()` instead of `future::future()`, the execution timeline would look like:

![future_promise() keeps the main R session free](./future_promise/blocked_future_promise.png){width=75%}

Only four main timepoints that caused the main R session to be busy. The remaining time allows for other `promises` objects (or `later` callbacks) to execute freely.

The video below animates how `future_promise()` leverages `promises` if no `future` workers are available:

```{r, echo = FALSE}
library(vembedr)
embed_vimeo("505286442") %>%
  use_align("center")
```




## Variable scope in `future_promise()` and `future::future()`

`future_promise()` is a promise **first** and executes using `future::future()` **second**. When using `future_promise()`, you should use the same precautions that you would use with a regular `promises::promise()`.

When `future` blocks on the main R session, this prevents values from being changed before they are submitted to the external worker.  While a `promise` waits to be executed, it is known that variables that have **not been `forced()`** or properly **scoped** can change from their expected values before evaluation occurs. This can also occur with properly scoped environment values as only the _pointer_ to the environment is static. This allows for the values within the environment to be altered before the `promise` is executed.


#### Scope

In the example below, the variable `i` is not forced to a specific value for the promise. With the promise resolving within the global environment, the latest `i` value will be used for all of the promises waiting to resolve.

```r
items <- list()
for (i in 1:10) {
  items <- c(items, list(
    promise_resolve(TRUE) %...>% {i}
  ))
}
promise_all(.list = items) %...>%
  { print(unlist(.)) }
# #> [1] 10 10 10 10 10 10 10 10 10 10
```

To combat variable scoping issues, functions can be used to create local environments that will _scope_ the expected `i` value.

```r
lapply(1:10, function(i) {
  promise_resolve(TRUE) %...>% {i}
}) %>%
  promise_all(.list = .) %...>%
  { print(unlist(.)) }
#> [1]  1  2  3  4  5  6  7  8  9 10
```


#### Changing environments

Environments can have their values changed after the original promise creation.  This can cause unexpected behavior when evaluating a promise.

For example, the environment `env` below will have its value `a` changed from `1` to `2` before the promise is resolved.  This causes the unexpected value of `2` to be returned in the promise.
```r
{
  env <- new.env()
  env$a <- 1

  promise_resolve(TRUE) %...>%
    { Sys.sleep(1); env$a } %...>%
    { print(.) }
  env$a <- 2
  print("Changed env$a")
}
#> [1] "Changed env$a"
#> [1] 2
```

To address lazy evaluation and environment variable issues, we can store the values to a local variable and force their evaluation.

Fixing the example, we can capture the value `a` (or turn the environment into a `list()`).
```r
{
  env <- new.env()
  env$a <- 1

  a_value <- force(env$a)
  promise_resolve(TRUE) %...>%
    { Sys.sleep(1); a_value } %...>%
    { print(.) }
  env$a <- 2
  print("done")
}
#> [1] "done"
#> [1] 1
```

The expression in `future_promise(expr)` will behave like a promise and should have its volitile variables scoped and `force()`ed to achieve similar evaluations when using `future::future()` directly.
